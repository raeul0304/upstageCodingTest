# upstageCodingTest
Coding Test Study in Upstage AI Lab

## Greedy
### Greedy_가장 큰 수 만들기
문제 : 각 자리가 숫자 (0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 ‘x’혹은 ‘+’연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요.

단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정합니다.

예를 들어, 02984라는 문자열로 만들 수 있는 가장 큰 수는 ((((0+2) x9) x8) x4) = 576입니다. 또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어집니다.

- input() 함수는 입력받은 값을 문자열 형태로 저장한다. 따라서 data는 문자열이고, 문자열은 파이썬에서 인덱싱이 가능한 시퀀스 타입이기 때문에 data[0]처럼 특정 위치의 문자에 접근할 수 있다
- result=0으로 초기화한 뒤 모든 문자를 처리하게 되면, result가 처음에는 항상 0이므로 첫 번째 문자도 더하기 연산이 되어버린다. 이렇게 되면, 원하는 연산 로직이 깨지게 되기 때문에 입력받은 수의 첫번째 문자를 저장한 것!


### Greedy_모험가 길드
문제 : 한 마을에 모함가가 N명 있다. 모험가 길드에서는 N명의 모함가를 대상으로 ‘공포도’를 측정했는데, **‘공포도’가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어진다.**

모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했다.

동빈이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금하다. N명의 모험가에 대한 정보가 주어졌을 때, **여행을 떠날 수 있는 그룹 수의 최댓값**을 구하는 프로그램을 작성하세요. 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없다

⇒ 오름차순으로 먼저 정렬을 한다

⇒ 앞에서부터 공포도를 하나씩 확인하며 ‘혀냊 그룹에 포함된 모험가의 수’가 ‘현재 확인하고 있는 공포도’보다 크거나 같다면 바로 그룹을 형성하면 된다

⇒ 이러한 방법을 이용하면 공포도가 오름차순으로 정렬되어 있다는 점에서, 항상 최소한의 모험가의 수만 포함하여 그룹을 결성하게 된다

### Greedy_1이 될 때까지
문제 : 어떠한 수 N이 1이 될때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다.단, 두 번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.

1. N에서 1을 뺀다
2. N을 K로 나눈다

예를 들어 N이 17, K가 4라고 가정하자. 이때 1번의 과정을 한 번 수행하면 N이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 된다. 이는 N을 만드는 최소 횟수이다.

N과 K가 주어질 때 N이 1이 될때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램을 작성하시오

⇒ 주어진 N에 대하여 최대한 많이 나누기를 수행하면 된다

⇒ N의 값을 줄일 때 2 이상의 수로 나누는 작업이 1을 빼는 작업보다 수를 훨씬 많이 줄일 수 있기 때문!



## 구현
### implement_왕실의 나이트 문제
문제 : 행복 왕국의 왕실 정원은 체스판과 같은 8x8 좌표 평면입니다. 왕실 정원의 특정한 한 칸에 나이트가 서있다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마한다.

나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다

나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동할 수 있다

1. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기
2. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기

주의 : **ord() : 문자를 아스키코드로 변환해주는 함수**
- ord('a')는 97을 반환
- ord('b')는 98을 반환
    
→ `int(ord(input_data[0])) - int(ord('a')) + 1` 라고 작성한 이유
    
⇒ ord(input_data[0]) - ord('a'): input_data[0]의 값이 a라면 0, b라면 1이 되도록 계산하여, a를 기준으로 몇 번째 열인지 계산
⇒ + 1: 체스판의 열 번호는 1부터 시작하므로, 이를 맞추기 위해 1을 더합니다.
