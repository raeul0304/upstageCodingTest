### **문제 설명**

각 칸마다 S, L, 또는 R가 써져 있는 격자가 있습니다. 당신은 이 격자에서 빛을 쏘고자 합니다. 이 격자의 각 칸에는 다음과 같은 특이한 성질이 있습니다.

- 빛이 "S"가 써진 칸에 도달한 경우, 직진합니다.
- 빛이 "L"이 써진 칸에 도달한 경우, 좌회전을 합니다.
- 빛이 "R"이 써진 칸에 도달한 경우, 우회전을 합니다.
- 빛이 격자의 끝을 넘어갈 경우, 반대쪽 끝으로 다시 돌아옵니다. 예를 들어, 빛이 1행에서 행이 줄어드는 방향으로 이동할 경우, 같은 열의 반대쪽 끝 행으로 다시 돌아옵니다.

당신은 이 격자 내에서 빛이 이동할 수 있는 경로 사이클이 몇 개 있고, 각 사이클의 길이가 얼마인지 알고 싶습니다. 경로 사이클이란, 빛이 이동하는 순환 경로를 의미합니다.

예를 들어, 다음 그림은 격자 `["SL","LR"]`에서 1행 1열에서 2행 1열 방향으로 빛을 쏠 경우, 해당 빛이 이동하는 경로 사이클을 표현한 것입니다.

!https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/f3c02c50-f82e-45d0-b633-ad3ecadba316/ex1.png

이 격자에는 길이가 16인 사이클 1개가 있으며, 다른 사이클은 존재하지 않습니다.

격자의 정보를 나타내는 1차원 문자열 배열 `grid`가 매개변수로 주어집니다. 주어진 격자를 통해 만들어지는 빛의 경로 사이클의 모든 길이들을 배열에 담아 오름차순으로 정렬하여 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

- 1 ≤ `grid`의 길이 ≤ 500
    - 1 ≤ `grid`의 각 문자열의 길이 ≤ 500
    - `grid`의 모든 문자열의 길이는 서로 같습니다.
    - `grid`의 모든 문자열은 `'L', 'R', 'S'`로 이루어져 있습니다.

---

### 풀이

- 방향 벡터(상,하,좌,우)와 방문 여부 변수를 먼저 정의해야 한다.

```python
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
```생략```
visited = [[[False] * 4 for _ in range(m)] for _ in range(n)]
```

- 순환 사이클의 갯수를 구하는 함수를 아래와 같이 정의해야 한다. 모든 d(방향)에 대하여 방문한 적 없는 노드일 때까지 반복하도록 하였다.

```python
def find_cycle(x, y, d):
    cnt = 0
    while not visited[x][y][d]:
        visited[x][y][d] = True
        cnt += 1
        x, y, d = move(x, y, d)
    return cnt
```

- S를 제외하고 L, R은 방향이 바뀌기 때문에 방향을 아래와 같이 수정하도록 하였다.

```python
def move(x, y, d):
    if grid[x][y] == 'L':
        # L이 나왔을 때 좌회전
        if d == 0:  # 상 -> 좌
            d = 2
        elif d == 1:  # 하 -> 우
            d = 3
        elif d == 2:  # 좌 -> 하
            d = 1
        elif d == 3:  # 우 -> 상
            d = 0
    elif grid[x][y] == 'R':
        # R이 나왔을 때 우회전
        if d == 0:  # 상 -> 우
            d = 3
        elif d == 1:  # 하 -> 좌
            d = 2
        elif d == 2:  # 좌 -> 상
            d = 0
        elif d == 3:  # 우 -> 하
            d = 1
    
    # 다음 위치로 이동
    x = (x + dx[d]) % n
    y = (y + dy[d]) % m
    
    return x, y, d
```