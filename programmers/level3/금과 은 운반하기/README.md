### **문제 설명**

어느 왕국에 하나 이상의 도시들이 있습니다. 왕국의 왕은 새 도시를 짓기로 결정하였습니다. 해당 도시를 짓기 위해서는 도시를 짓는 장소에 금 `a` kg과 은 `b` kg이 전달되어야 합니다.

각 도시에는 번호가 매겨져 있는데, `i`번 도시에는 금 `g[i]` kg, 은 `s[i]` kg, 그리고 트럭 한 대가 있습니다. `i`번 도시의 트럭은 오직 새 도시를 짓는 건설 장소와 `i`번 도시만을 왕복할 수 있으며, 편도로 이동하는 데 `t[i]` 시간이 걸리고, 최대 `w[i]` kg 광물을 운반할 수 있습니다. (광물은 금과 은입니다. 즉, 금과 은을 동시에 운반할 수 있습니다.) 모든 트럭은 같은 도로를 여러 번 왕복할 수 있으며 연료는 무한대라고 가정합니다.

정수 `a`, `b`와 정수 배열 `g`, `s`, `w`, `t`가 매개변수로 주어집니다. 주어진 정보를 바탕으로 각 도시의 트럭을 최적으로 운행했을 때, 새로운 도시를 건설하기 위해 금 `a` kg과 은 `b` kg을 전달할 수 있는 가장 빠른 시간을 구해 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

- 0 ≤ `a`, `b` ≤ 10^9
- 1 ≤ `g`의 길이 = `s`의 길이 = `w`의 길이 = `t`의 길이 = 도시 개수 ≤ 10^5
    - 0 ≤ `g[i]`, `s[i]` ≤ 10^9
    - 1 ≤ `w[i]` ≤ 10^2
    - 1 ≤ `t[i]` ≤ 10^5
    - `a` ≤ `g`의 모든 수의 합
    - `b` ≤ `s`의 모든 수의 합

---

### 풀이

- 우선 문제에 맞게 110 이라는 문자열이 제거되어야 하므로 아래와 같이 stack 알고리즘으로 하나씩 쌓은 다음 pop하도록 작성하였다.

```python
stack = []
for ch in x:
    stack.append(ch)
    while stack[-3:] == mask:
        for _ in range(3):
            stack.pop()
```

- 위에서 stack에서 110을 제거한 다음 join을 거쳐 하나의 문자열이 재생성 되었다면 이제 그 문자열에서 111 또는 0을 찾아서 그 다음 인덱스부터 110을 붙이면 사전 순 가장 앞에 오는 문자열이 될 수 있다고 판단하고 아래와 같이 작성하였다.

```python
insert_idx = remained.find('111')
if insert_idx < 0:
    insert_idx = remained.rfind('0') + 1
final_str = remained[:insert_idx] + '110' * removed_cnt + remained[insert_idx:]
```