### **문제 설명**

`n`행 `m`열의 격자가 있습니다. 격자의 각 행은 0, 1, ..., `n-1`번의 번호, 그리고 각 열은 0, 1, ..., `m-1`번의 번호가 순서대로 매겨져 있습니다. 당신은 이 격자에 공을 하나 두고, 그 공에 다음과 같은 쿼리들을 날리고자 합니다.

- 열 번호가 감소하는 방향으로 `dx`칸 이동하는 쿼리 (`query(0, dx)`)
- 열 번호가 증가하는 방향으로 `dx`칸 이동하는 쿼리 (`query(1, dx)`)
- 행 번호가 감소하는 방향으로 `dx`칸 이동하는 쿼리 (`query(2, dx)`)
- 행 번호가 증가하는 방향으로 `dx`칸 이동하는 쿼리 (`query(3, dx)`)

단, 공은 격자 바깥으로 이동할 수 없으며, 목적지가 격자 바깥인 경우 공은 이동하다가 더 이상 이동할 수 없을 때 멈추게 됩니다. 예를 들어, 5행 × 4열 크기의 격자 내의 공이 3행 2열에 있을 때 `query(3, 10)` 쿼리를 받은 경우 공은 4행 2열에서 멈추게 됩니다. (격자의 크기가 5행 × 4열이므로, 0~4번 행과 0~3번 열로 격자가 구성되기 때문입니다.)

격자의 행의 개수 `n`, 열의 개수 `m`, 정수 `x`와 `y`, 그리고 쿼리들의 목록을 나타내는 2차원 정수 배열 `queries`가 매개변수로 주어집니다. `n × m`개의 가능한 시작점에 대해서 해당 시작점에 공을 두고 `queries` 내의 쿼리들을 순서대로 시뮬레이션했을 때, `x`행 `y`열에 도착하는 시작점의 개수를 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

- 1 ≤ `n` ≤ 10^9
- 1 ≤ `m` ≤ 10^9
- 0 ≤ `x` < n
- 0 ≤ `y` < m
- 1 ≤ `queries`의 행의 개수 ≤ 200,000
    - `queries`의 각 행은 `[command,dx]` 두 정수로 이루어져 있습니다.
    - 0 ≤ `command` ≤ 3
    - 1 ≤ `dx` ≤ 10^9
    - 이는 `query(command, dx)`를 의미합니다.

---

### 풀이

- 처음 마주하였을 때에는 (0,0)~(n-1,m-1)까지 모두 반복하면서 돌아야 하나 생각하였지만 그렇게 할 경우 시간복잡도 측면에서 비효율적이므로 아래와 같이 정답이 x,y에 올 수 있는 경우를 구하는 것이라면 해당 목적지부터 reverse하여 그 구간을 구하면 정답이라는 것을 깨달을 수 있었다.

```python
x_min, x_max, y_min, y_max = x, x, y, y
for i in range(len(queries)-1, -1, -1):
		way, dx = queries[i]
```

- 이후의 코드들은 반복성이므로 하나의 예시상황만 가져와서 보자면 목적지부터 시작하는 거꾸로의 상황이 되므로 그 상황에 맞게 사칙연산을 진행하고 벽에 부딪히면 최대치와 최소치로 재설정하는 과정, 그리고 범위 상의 max, min도 dx에 맞게 사칙연산을 진행해주면 된다.

```python
if way == 0: # 실제: 좌측 이동 / 거꾸로: 우측 이동
    y_max += dx
    if y_max > m-1: # 벽에 부딪힌 경우
        y_max = m-1 # 최대치로 재설정
    if y_min != 0: 
        y_min += dx # 갈 수 있는 지역 축소
```